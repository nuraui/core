[Partial Hydration]: https://jasonformat.com/islands-architecture/
[Astro]: https://docs.astro.build/core-concepts/component-hydration
[requestIdleCallback]: https://developer.mozilla.org/en-US/docs/Web/API/Window/requestIdleCallback
[intersectionobserver]: https://developer.mozilla.org/en-US/docs/Web/API/Intersection_Observer_API
[matchMedia]: https://developer.mozilla.org/en-US/docs/Web/API/Window/matchMedia

[Preact]: /guide/plugins#preactpreset-vite
[SolidJS]: /guide/plugins#vite-plugin-solid
[Svelte]: /guide/plugins#sveltejsvite-plugin-svelte
[Suspense]: https://vuejs.org/guide/built-ins/suspense
[Demo]: https://the-vue-point-with-iles.netlify.app/cat-zone
[blog repo]: https://github.com/ElMassimo/iles/blob/main/playground/the-vue-point/src/components/CatDisplay.vue

# Hydration Directives <Logo/>

<Iles/> uses the Islands Architecture. It creates fast, static web pages with only small interactive parts, like a carousel that requires JavaScript.

> Learn about the Islands Architecture from the [Astro](https://docs.astro.build/en/concepts/islands/) docs, Jason Miller's [blog](https://jasonformat.com/islands-architecture/), and his [keynote](https://www.youtube.com/watch?v=k-A2VfuUROg&t=969s).

## ﾃ四es vs Petite-Vue

<VueLogo/> Petite-Vue lets you <kbd>progressively enhance</kbd> your server-rendered or statically generated HTML pages with sprinkes of interactivity. This can be done either through a global app (for the whole page) or with multiple ﾃｮslands of interactivity.

<Iles/> additionally lets you <kbd>progressively hydrate</kbd> (when to hydrate) your server-rendered or statically generated HTML pages with ﾃｮslands of interactivity. It follows a component-driven workflow delivering a simple yet powerful development experience, thanks to <VueLogo/> and <ViteLogo/>.

## ﾃ四es vs Nuxt

<Iles/> follow an architecture where <kbd>dynamic ﾃｮslands</kbd> are embedded within a static page. Hydration strategies are mandatory to make components interactive.

<NuxtLogo/> Nuxt, on the contrary, follows an architecture where <kbd>static ﾃｮslands</kbd> are embedded within a dynamic app. Marking components as [server components] are optional.

> Learn more about this architectural difference in Daniel Roe's blog post [here](https://roe.dev/blog/nuxt-server-components).

## Hydration Strategies

You can define which components in your ﾃｮles project should remain interactive in the production build by using `client:` directives in your components (borrowed from [Astro]).

Any JS required for these components will be automatically inferred and optimized to perform partial hydration in the final build.

> No JS is shipped unless you use a hydration strategy! 沛

> ﾃ四es doesn't support an ﾃｮsland within another ﾃｮsland, so do not nest ﾃｮslands in your project.

Here's an example with MDX, an interactive audio player in a mostly static page:

```mdx
---
title: Song for You
audio: /song-for-you.mp3
---

I've recently recorded a song, listen:

<AudioPlayer {...frontmatter} client:visible/>
```

You can also use these directives inside your Vue components. In the following
example, the _Download_ link is rendered statically, while the `<Audio>`
component is interactive and will be hydrated when visible.

```vue
<template>
  <div class="audio-player">
    <Audio client:visible :src="audio" :initialDuration="initialDuration"/>
    <div>
      <a :href="audio" :download="`${title}.mp3`">
        Download the Song
      </a>
    </div>
  </div>
</template>
```

The following hydration strategies are available.

## 沛 client:load
Hydrates the component immediately as the page loads.

```vue
<DarkModeSwitch client:load/>
```

## 沛 client:idle
Hydrate the component as soon as the main thread is [free][requestIdleCallback].

```vue
<TimeAgo :date="date" client:idle/>
```

## 沛 client:visible
Hydrates the component as soon as the element [enters the viewport][intersectionobserver].

```vue
<AudioPlayer :src="/example.mp3" client:visible/>
```

## 沛 client:media
Hydrates the component as soon as the browser [matches the given media query][matchMedia].

Useful to avoid unnecessary work depending on the available viewport, such as in mobile devices.

```vue
<Sidebar client:media="screen and (min-width: 600px)"/>
```

## 沛 client:none
Does not hydrate the component in the client, it will be prerendered as static HTML.

Allows <Iles/> to detect [Preact], [SolidJS], or [Svelte] components embedded in Vue or MDX files.

<Tip title="No JS will be shipped in the build">
You should use any of the other directives if you want the component to be interactive.
</Tip>

## 沛 client:only
Does not prerender the component during build.

<Tip warn>
Because it's not pre-rendered it could cause [layout shift] and affect the user experience.

Prefer one of the previous strategies whenever possible.
</Tip>

[layout shift]: https://web.dev/cls/

## 汳ｫ Suspense

ﾃ四es automatically wraps ﾃｮslands with the Vue [Suspense] component when they use the `<script setup>` with top-level `await` expressions.

This automatic suspense handling means you don't need to restructure your components to accomodate suspense logic manually. It is particularly useful when fetching data from external sources, such as databases or headless CMSs, within your island on the client side.

In the following example from [The Vue Point in ﾃｮles][demo] ([repo][blog repo]), the `CatDisplay` ﾃｮsland is loaded from the parent component and hydrated using the `client:load` directive.

```vue
<!-- cat-zone.mdx page -->
<CatDisplay client:load />
```

The `CatDisplay` ﾃｮsland fetches a random cat image from an API source. 

```vue
<!-- CatDisplay.vue -->
<script setup lang="ts">
import {$fetch} from 'ofetch'
const data = ref()
const isLoading = ref(true)
const error = ref(false)

await $fetch('https://api.thecatapi.com/v1/images/search', {
  async onResponse({request, response, options}) {
    isLoading.value = false
    data.value = response._data[0]
  },
  async onResponseError({request, response, options}) {
    error.value = true
  },
})
</script>

<template>
  <p v-if="isLoading">Loading...</p>
  <img
    v-else
    :src="data.url"
    alt="Boots"
    style="object-fit: cover; max-height: 600px" />
  <p v-if="error">Oops! An error occured, please try again.</p>
</template>
```

You can still manually handle [Suspense] yourselves if you want to use it's loading / error states, and don't mind create a child component to handle the asynchronous data fetch.

To illustrate, the top-level `await` in the above example and the `<img>` tag can be moved into a child component called `<CatOfTheDay>`. Then, the loading / error states of [Suspense] can be implemented like below.

```vue
<!-- cat-zone.mdx page -->
<CatDisplay client:load />
```

```vue
<!-- CatDisplay.vue -->
<template>
  <Suspense>
    <CatOfTheDay />
    <template #fallback><p>Loading...</p></template>
  </Suspense>
</template>
```

```vue
<!-- CatOfTheDay.vue -->
<script setup lang="ts">
  import {$fetch} from 'ofetch'
  const [data] = await $fetch('https://api.thecatapi.com/v1/images/search')
</script>

<template>
  <img
    :src="data.url"
    alt="Awiwi"
    style="object-fit: cover; max-height: 600px" />
</template>
```